// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAllApps = `-- name: GetAllApps :many
SELECT id, name FROM core.apps ORDER BY created_at DESC
`

type GetAllAppsRow struct {
	ID   uuid.UUID `json:"id"`
	Name []byte    `json:"name"`
}

func (q *Queries) GetAllApps(ctx context.Context) ([]GetAllAppsRow, error) {
	rows, err := q.db.Query(ctx, getAllApps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAppsRow{}
	for rows.Next() {
		var i GetAllAppsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, app_id, name, email 
FROM core.users 
ORDER BY created_at DESC
`

type GetAllUsersRow struct {
	ID    uuid.UUID `json:"id"`
	AppID uuid.UUID `json:"app_id"`
	Name  string    `json:"name"`
	Email string    `json:"email"`
}

func (q *Queries) GetAllUsers(ctx context.Context) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersRow{}
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.AppID,
			&i.Name,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersByAppID = `-- name: GetAllUsersByAppID :many
SELECT id, name, email 
FROM core.users 
WHERE app_id=$1 
ORDER BY created_at DESC
`

type GetAllUsersByAppIDRow struct {
	ID    uuid.UUID `json:"id"`
	Name  string    `json:"name"`
	Email string    `json:"email"`
}

func (q *Queries) GetAllUsersByAppID(ctx context.Context, appID uuid.UUID) ([]GetAllUsersByAppIDRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersByAppID, appID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersByAppIDRow{}
	for rows.Next() {
		var i GetAllUsersByAppIDRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppByID = `-- name: GetAppByID :one
SELECT id, name, created_at, updated_at FROM core.apps WHERE id = $1
`

func (q *Queries) GetAppByID(ctx context.Context, id uuid.UUID) (CoreApp, error) {
	row := q.db.QueryRow(ctx, getAppByID, id)
	var i CoreApp
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppUserByID = `-- name: GetAppUserByID :one
SELECT id, app_id, name, email, is_email_verified, email_verified_at 
FROM core.users 
WHERE app_id = $1 AND id = $2
`

type GetAppUserByIDParams struct {
	AppID uuid.UUID `json:"app_id"`
	ID    uuid.UUID `json:"id"`
}

type GetAppUserByIDRow struct {
	ID              uuid.UUID          `json:"id"`
	AppID           uuid.UUID          `json:"app_id"`
	Name            string             `json:"name"`
	Email           string             `json:"email"`
	IsEmailVerified bool               `json:"is_email_verified"`
	EmailVerifiedAt pgtype.Timestamptz `json:"email_verified_at"`
}

func (q *Queries) GetAppUserByID(ctx context.Context, arg GetAppUserByIDParams) (GetAppUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getAppUserByID, arg.AppID, arg.ID)
	var i GetAppUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Name,
		&i.Email,
		&i.IsEmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const getRefreshTokenByJTI = `-- name: GetRefreshTokenByJTI :one
SELECT jti, user_id, app_id, token, expires_at, is_active, created_at 
FROM core.refresh_tokens 
WHERE app_id = $1 AND jti = $2 
ORDER BY created_at
`

type GetRefreshTokenByJTIParams struct {
	AppID uuid.UUID `json:"app_id"`
	Jti   string    `json:"jti"`
}

type GetRefreshTokenByJTIRow struct {
	Jti       string             `json:"jti"`
	UserID    uuid.UUID          `json:"user_id"`
	AppID     uuid.UUID          `json:"app_id"`
	Token     string             `json:"token"`
	ExpiresAt time.Time          `json:"expires_at"`
	IsActive  bool               `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetRefreshTokenByJTI(ctx context.Context, arg GetRefreshTokenByJTIParams) (GetRefreshTokenByJTIRow, error) {
	row := q.db.QueryRow(ctx, getRefreshTokenByJTI, arg.AppID, arg.Jti)
	var i GetRefreshTokenByJTIRow
	err := row.Scan(
		&i.Jti,
		&i.UserID,
		&i.AppID,
		&i.Token,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getUserActiveRefreshTokensByJTI = `-- name: GetUserActiveRefreshTokensByJTI :many
SELECT jti, user_id, app_id, token, is_active, created_at, expires_at FROM core.refresh_tokens
WHERE app_id = $1 AND jti = $2 AND is_active = true
ORDER BY created_at DESC
`

type GetUserActiveRefreshTokensByJTIParams struct {
	AppID uuid.UUID `json:"app_id"`
	Jti   string    `json:"jti"`
}

func (q *Queries) GetUserActiveRefreshTokensByJTI(ctx context.Context, arg GetUserActiveRefreshTokensByJTIParams) ([]CoreRefreshToken, error) {
	rows, err := q.db.Query(ctx, getUserActiveRefreshTokensByJTI, arg.AppID, arg.Jti)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreRefreshToken{}
	for rows.Next() {
		var i CoreRefreshToken
		if err := rows.Scan(
			&i.Jti,
			&i.UserID,
			&i.AppID,
			&i.Token,
			&i.IsActive,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActiveRefreshTokensByUserID = `-- name: GetUserActiveRefreshTokensByUserID :many
SELECT jti, user_id, app_id, token, is_active, created_at, expires_at FROM core.refresh_tokens
WHERE app_id = $1 AND user_id = $2 AND is_active = true
ORDER BY created_at DESC
`

type GetUserActiveRefreshTokensByUserIDParams struct {
	AppID  uuid.UUID `json:"app_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetUserActiveRefreshTokensByUserID(ctx context.Context, arg GetUserActiveRefreshTokensByUserIDParams) ([]CoreRefreshToken, error) {
	rows, err := q.db.Query(ctx, getUserActiveRefreshTokensByUserID, arg.AppID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreRefreshToken{}
	for rows.Next() {
		var i CoreRefreshToken
		if err := rows.Scan(
			&i.Jti,
			&i.UserID,
			&i.AppID,
			&i.Token,
			&i.IsActive,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAuthenticationByProvider = `-- name: GetUserAuthenticationByProvider :one
SELECT user_id, app_id, provider, provider_user_id, password, created_at, updated_at 
FROM core.user_auth_providers 
WHERE app_id = $1 AND user_id = $2 AND provider = $3
`

type GetUserAuthenticationByProviderParams struct {
	AppID    uuid.UUID `json:"app_id"`
	UserID   uuid.UUID `json:"user_id"`
	Provider string    `json:"provider"`
}

func (q *Queries) GetUserAuthenticationByProvider(ctx context.Context, arg GetUserAuthenticationByProviderParams) (CoreUserAuthProvider, error) {
	row := q.db.QueryRow(ctx, getUserAuthenticationByProvider, arg.AppID, arg.UserID, arg.Provider)
	var i CoreUserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.AppID,
		&i.Provider,
		&i.ProviderUserID,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, app_id, name, email, is_email_verified, email_verified_at, created_at, updated_at 
FROM core.users 
WHERE app_id = $1 AND email = $2
`

type GetUserByEmailParams struct {
	AppID uuid.UUID `json:"app_id"`
	Email string    `json:"email"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (CoreUser, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, arg.AppID, arg.Email)
	var i CoreUser
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Name,
		&i.Email,
		&i.IsEmailVerified,
		&i.EmailVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const lockAppForUpdate = `-- name: LockAppForUpdate :one
SELECT id FROM core.apps WHERE id = $1 FOR UPDATE
`

func (q *Queries) LockAppForUpdate(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, lockAppForUpdate, id)
	err := row.Scan(&id)
	return id, err
}

const revokeActiveAppApiKeys = `-- name: RevokeActiveAppApiKeys :execrows
UPDATE core.app_api_keys 
SET is_active = false, revoked_at = $2 
WHERE app_id = $1 AND is_active = true
`

type RevokeActiveAppApiKeysParams struct {
	AppID     uuid.UUID          `json:"app_id"`
	RevokedAt pgtype.Timestamptz `json:"revoked_at"`
}

func (q *Queries) RevokeActiveAppApiKeys(ctx context.Context, arg RevokeActiveAppApiKeysParams) (int64, error) {
	result, err := q.db.Exec(ctx, revokeActiveAppApiKeys, arg.AppID, arg.RevokedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const revokeRefreshTokens = `-- name: RevokeRefreshTokens :exec
UPDATE core.refresh_tokens 
SET is_active = false 
WHERE app_id = $1 AND user_id = $2 AND jti = ANY($3::text[])
`

type RevokeRefreshTokensParams struct {
	AppID  uuid.UUID `json:"app_id"`
	UserID uuid.UUID `json:"user_id"`
	Jtis   []string  `json:"jtis"`
}

func (q *Queries) RevokeRefreshTokens(ctx context.Context, arg RevokeRefreshTokensParams) error {
	_, err := q.db.Exec(ctx, revokeRefreshTokens, arg.AppID, arg.UserID, arg.Jtis)
	return err
}

const storeApp = `-- name: StoreApp :exec
INSERT INTO core.apps (id, name) 
VALUES ($1, $2)
`

type StoreAppParams struct {
	ID   uuid.UUID `json:"id"`
	Name []byte    `json:"name"`
}

func (q *Queries) StoreApp(ctx context.Context, arg StoreAppParams) error {
	_, err := q.db.Exec(ctx, storeApp, arg.ID, arg.Name)
	return err
}

const storeAppApiKey = `-- name: StoreAppApiKey :exec
INSERT INTO core.app_api_keys (id, app_id, key_hash, is_active) 
VALUES ($1, $2, $3, $4)
`

type StoreAppApiKeyParams struct {
	ID       uuid.UUID `json:"id"`
	AppID    uuid.UUID `json:"app_id"`
	KeyHash  string    `json:"key_hash"`
	IsActive bool      `json:"is_active"`
}

func (q *Queries) StoreAppApiKey(ctx context.Context, arg StoreAppApiKeyParams) error {
	_, err := q.db.Exec(ctx, storeAppApiKey,
		arg.ID,
		arg.AppID,
		arg.KeyHash,
		arg.IsActive,
	)
	return err
}

const storeRefreshToken = `-- name: StoreRefreshToken :exec
INSERT INTO core.refresh_tokens (jti, user_id, app_id, token, expires_at, is_active) 
VALUES ($1, $2, $3, $4, $5, $6)
`

type StoreRefreshTokenParams struct {
	Jti       string    `json:"jti"`
	UserID    uuid.UUID `json:"user_id"`
	AppID     uuid.UUID `json:"app_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
	IsActive  bool      `json:"is_active"`
}

func (q *Queries) StoreRefreshToken(ctx context.Context, arg StoreRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, storeRefreshToken,
		arg.Jti,
		arg.UserID,
		arg.AppID,
		arg.Token,
		arg.ExpiresAt,
		arg.IsActive,
	)
	return err
}

const storeUser = `-- name: StoreUser :exec
INSERT INTO core.users (id, app_id, name, email, is_email_verified, email_verified_at) 
VALUES ($1, $2, $3, $4, $5, $6)
`

type StoreUserParams struct {
	ID              uuid.UUID          `json:"id"`
	AppID           uuid.UUID          `json:"app_id"`
	Name            string             `json:"name"`
	Email           string             `json:"email"`
	IsEmailVerified bool               `json:"is_email_verified"`
	EmailVerifiedAt pgtype.Timestamptz `json:"email_verified_at"`
}

func (q *Queries) StoreUser(ctx context.Context, arg StoreUserParams) error {
	_, err := q.db.Exec(ctx, storeUser,
		arg.ID,
		arg.AppID,
		arg.Name,
		arg.Email,
		arg.IsEmailVerified,
		arg.EmailVerifiedAt,
	)
	return err
}

const storeUserAuthProvider = `-- name: StoreUserAuthProvider :exec
INSERT INTO core.user_auth_providers (user_id, app_id, provider, provider_user_id, password) 
VALUES ($1, $2, $3, $4, $5)
`

type StoreUserAuthProviderParams struct {
	UserID         uuid.UUID `json:"user_id"`
	AppID          uuid.UUID `json:"app_id"`
	Provider       string    `json:"provider"`
	ProviderUserID *string   `json:"provider_user_id"`
	Password       *string   `json:"password"`
}

func (q *Queries) StoreUserAuthProvider(ctx context.Context, arg StoreUserAuthProviderParams) error {
	_, err := q.db.Exec(ctx, storeUserAuthProvider,
		arg.UserID,
		arg.AppID,
		arg.Provider,
		arg.ProviderUserID,
		arg.Password,
	)
	return err
}
